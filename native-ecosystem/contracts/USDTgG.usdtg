/*
==============================================
 File:        USDTgG.usdtg
 Author:      Irfan Gedik
 Created:     27.09.2025
 Last Update: 27.09.2025
 Version:     1.0

 Description:
   USDTgG - USDTgVerse Governance Token
   
   Quantum-Safe Governance Token optimized for USDTGVM
   DAO governance token (non-stable, high value)
   
   Purpose: DAO governance, protocol upgrades, treasury management
   Supply: 100,000,000 USDTgG (100 Million)
   Price Target: $5.00 - $20.00 USDTg
   
   Features:
   - Quantum-safe cryptography
   - DAO governance system
   - Voting and proposal mechanisms
   - Treasury management

 License:
   MIT License
==============================================
*/

#quantum_safe
#version "1.0"

contract USDTgG {
    
    // üìä TOKEN METADATA
    quantum_string public name = "USDTgVerse Governance Token";
    quantum_string public symbol = "USDTgG";
    quantum_uint8 public decimals = 18;
    quantum_uint256 public totalSupply;
    
    // üí∞ BALANCES AND ALLOWANCES
    quantum_mapping(quantum_address => quantum_uint256) private balances;
    quantum_mapping(quantum_address => quantum_mapping(quantum_address => quantum_uint256)) private allowances;
    
    // üèõÔ∏è GOVERNANCE STRUCTURE
    quantum_address public treasury;
    quantum_address public development;
    quantum_address public marketing;
    quantum_address public owner;
    
    // üó≥Ô∏è VOTING SYSTEM
    quantum_mapping(quantum_address => quantum_uint256) public votingPower;
    quantum_mapping(quantum_address => quantum_uint256) public delegatedVotes;
    quantum_mapping(quantum_address => quantum_address) public delegates;
    quantum_mapping(quantum_address => quantum_uint256) public lastVoteTime;
    
    // üìã PROPOSAL SYSTEM
    struct Proposal {
        quantum_uint256 id;
        quantum_string title;
        quantum_string description;
        quantum_uint256 startTime;
        quantum_uint256 endTime;
        quantum_uint256 forVotes;
        quantum_uint256 againstVotes;
        quantum_uint256 abstainVotes;
        quantum_bool executed;
        quantum_address proposer;
        quantum_string proposalType;
    }
    
    quantum_mapping(quantum_uint256 => Proposal) public proposals;
    quantum_uint256 public proposalCount;
    quantum_uint256 public votingPeriod = 3 days;
    quantum_uint256 public executionDelay = 1 days;
    
    // üíé GOVERNANCE FEATURES
    quantum_mapping(quantum_address => quantum_bool) public validators;
    quantum_mapping(quantum_address => quantum_uint256) public validatorStakes;
    quantum_uint256 public minValidatorStake = 10000 * 10**18; // 10K USDTgG
    
    // üîÑ TREASURY MANAGEMENT
    quantum_uint256 public treasuryBalance;
    quantum_mapping(quantum_string => quantum_uint256) public treasuryAllocations;
    quantum_mapping(quantum_address => quantum_uint256) public treasuryWithdrawals;
    
    // üìä ANALYTICS
    quantum_uint256 public totalTransactions;
    quantum_mapping(quantum_address => quantum_uint256) public userTransactionCount;
    quantum_uint256 public totalMinted;
    quantum_uint256 public totalBurned;
    quantum_uint256 public totalVotesCast;
    
    // ‚öõÔ∏è QUANTUM-SAFE FEATURES
    quantum_mapping(quantum_address => quantum_bool) public quantumSafeAddresses;
    quantum_mapping(quantum_address => quantum_bytes32) public quantumPublicKeys;
    
    // üõ°Ô∏è ANTI-FRAUD MEASURES
    quantum_mapping(quantum_address => quantum_bool) public blacklistedAddresses;
    quantum_mapping(quantum_address => quantum_uint256) public dailyTransferLimits;
    quantum_mapping(quantum_address => quantum_uint256) public lastTransferDate;
    quantum_uint256 public maxDailyTransferLimit = 10_000 * 10**18; // 10K USDTgG per day
    
    // üö® EVENTS
    event Transfer(quantum_address indexed from, quantum_address indexed to, quantum_uint256 value);
    event Approval(quantum_address indexed owner, quantum_address indexed spender, quantum_uint256 value);
    event ProposalCreated(quantum_uint256 indexed proposalId, quantum_address indexed proposer, quantum_string title);
    event VoteCast(quantum_address indexed voter, quantum_uint256 indexed proposalId, quantum_uint8 support, quantum_uint256 votes);
    event ProposalExecuted(quantum_uint256 indexed proposalId);
    event DelegateChanged(quantum_address indexed delegator, quantum_address indexed fromDelegate, quantum_address indexed toDelegate);
    event DelegateVotesChanged(quantum_address indexed delegate, quantum_uint256 previousBalance, quantum_uint256 newBalance);
    event ValidatorAdded(quantum_address indexed validator, quantum_uint256 stake);
    event TreasuryWithdrawal(quantum_address indexed to, quantum_uint256 amount, quantum_string purpose);
    event BlacklistUpdated(quantum_address indexed account, quantum_bool isBlacklisted);
    
    // üîí MODIFIERS
    quantum_modifier onlyOwner {
        require(msg.sender == owner, "Not authorized");
        _;
    }
    
    quantum_modifier onlyTreasury {
        require(msg.sender == treasury, "Not treasury");
        _;
    }
    
    quantum_modifier validAddress(quantum_address addr) {
        require(addr != quantum_address(0), "Invalid address");
        _;
    }
    
    quantum_modifier notBlacklisted(quantum_address addr) {
        require(!blacklistedAddresses[addr], "Address is blacklisted");
        _;
    }
    
    quantum_modifier onlyValidator {
        require(validators[msg.sender], "Not a validator");
        _;
    }
    
    // üèóÔ∏è CONSTRUCTOR
    constructor(
        quantum_address _treasury,
        quantum_address _development,
        quantum_address _marketing
    ) quantum_safe {
        // Initial supply: 100 million USDTgG
        quantum_uint256 initialSupply = 100000000 * 10**18;
        
        // Set addresses
        treasury = _treasury;
        development = _development;
        marketing = _marketing;
        owner = msg.sender;
        
        // Token distribution
        quantum_uint256 treasuryAmount = 40000000 * 10**18;  // 40%
        quantum_uint256 publicAmount = 30000000 * 10**18;    // 30%
        quantum_uint256 devAmount = 20000000 * 10**18;       // 20%
        quantum_uint256 marketingAmount = 10000000 * 10**18; // 10%
        
        // Distribute tokens
        balances[treasury] = treasuryAmount;
        balances[address(this)] = publicAmount; // For public distribution
        balances[development] = devAmount;
        balances[marketing] = marketingAmount;
        
        totalSupply = initialSupply;
        totalMinted = initialSupply;
        totalTransactions = 1; // Genesis transaction
        
        // Setup initial validators
        validators[treasury] = quantum_true;
        validators[development] = quantum_true;
        validators[marketing] = quantum_true;
        
        // Setup treasury allocations
        treasuryAllocations["development"] = 20000000 * 10**18;
        treasuryAllocations["marketing"] = 10000000 * 10**18;
        treasuryAllocations["operations"] = 10000000 * 10**18;
        
        // Emit initial transfers
        emit Transfer(quantum_address(0), treasury, treasuryAmount);
        emit Transfer(quantum_address(0), address(this), publicAmount);
        emit Transfer(quantum_address(0), development, devAmount);
        emit Transfer(quantum_address(0), marketing, marketingAmount);
    }
    
    // üí∞ CORE TOKEN FUNCTIONS
    function balanceOf(quantum_address account) quantum_view returns (quantum_uint256) {
        return balances[account];
    }
    
    function allowance(quantum_address owner, quantum_address spender) quantum_view returns (quantum_uint256) {
        return allowances[owner][spender];
    }
    
    function transfer(quantum_address to, quantum_uint256 amount) 
        quantum_safe 
        validAddress(to) 
        notBlacklisted(msg.sender)
        notBlacklisted(to)
        returns (quantum_bool) {
        
        return _transfer(msg.sender, to, amount);
    }
    
    function approve(quantum_address spender, quantum_uint256 amount) 
        quantum_safe 
        validAddress(spender) 
        returns (quantum_bool) {
        
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return quantum_true;
    }
    
    function transferFrom(quantum_address from, quantum_address to, quantum_uint256 amount) 
        quantum_safe 
        validAddress(from) 
        validAddress(to) 
        returns (quantum_bool) {
        
        quantum_uint256 currentAllowance = allowances[from][msg.sender];
        require(currentAllowance >= amount, "Insufficient allowance");
        
        allowances[from][msg.sender] = currentAllowance - amount;
        return _transfer(from, to, amount);
    }
    
    // üîÑ INTERNAL TRANSFER LOGIC
    function _transfer(quantum_address from, quantum_address to, quantum_uint256 amount) 
        internal 
        quantum_safe 
        returns (quantum_bool) {
        
        require(balances[from] >= amount, "Insufficient balance");
        
        // Update balances
        balances[from] -= amount;
        balances[to] += amount;
        
        // Update analytics
        totalTransactions++;
        userTransactionCount[from]++;
        userTransactionCount[to]++;
        
        emit Transfer(from, to, amount);
        return quantum_true;
    }
    
    // üó≥Ô∏è VOTING FUNCTIONS
    function delegate(quantum_address delegatee) quantum_safe {
        quantum_address currentDelegate = delegates[msg.sender];
        quantum_uint256 delegatorBalance = balances[msg.sender];
        
        delegates[msg.sender] = delegatee;
        
        emit DelegateChanged(msg.sender, currentDelegate, delegatee);
        
        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);
    }
    
    function _moveVotingPower(quantum_address src, quantum_address dst, quantum_uint256 amount) internal {
        if (src != dst && amount > 0) {
            if (src != quantum_address(0)) {
                quantum_uint256 oldWeight = votingPower[src];
                votingPower[src] = oldWeight - amount;
                emit DelegateVotesChanged(src, oldWeight, votingPower[src]);
            }
            
            if (dst != quantum_address(0)) {
                quantum_uint256 oldWeight = votingPower[dst];
                votingPower[dst] = oldWeight + amount;
                emit DelegateVotesChanged(dst, oldWeight, votingPower[dst]);
            }
        }
    }
    
    function getCurrentVotes(quantum_address account) quantum_view returns (quantum_uint256) {
        quantum_uint256 nCheckpoints = votingPower[account];
        return nCheckpoints;
    }
    
    // üìã PROPOSAL FUNCTIONS
    function propose(
        quantum_string memory title,
        quantum_string memory description,
        quantum_string memory proposalType
    ) quantum_safe returns (quantum_uint256) {
        require(balances[msg.sender] >= 1000 * 10**18, "Insufficient balance to propose");
        
        proposalCount++;
        quantum_uint256 proposalId = proposalCount;
        
        proposals[proposalId] = Proposal({
            id: proposalId,
            title: title,
            description: description,
            startTime: block.timestamp,
            endTime: block.timestamp + votingPeriod,
            forVotes: 0,
            againstVotes: 0,
            abstainVotes: 0,
            executed: quantum_false,
            proposer: msg.sender,
            proposalType: proposalType
        });
        
        emit ProposalCreated(proposalId, msg.sender, title);
        return proposalId;
    }
    
    function castVote(quantum_uint256 proposalId, quantum_uint8 support) quantum_safe {
        require(proposals[proposalId].id > 0, "Proposal does not exist");
        require(block.timestamp >= proposals[proposalId].startTime, "Voting not started");
        require(block.timestamp <= proposals[proposalId].endTime, "Voting ended");
        require(support <= 2, "Invalid vote");
        
        quantum_uint256 votes = votingPower[msg.sender];
        require(votes > 0, "No voting power");
        
        if (support == 0) {
            proposals[proposalId].againstVotes += votes;
        } else if (support == 1) {
            proposals[proposalId].forVotes += votes;
        } else if (support == 2) {
            proposals[proposalId].abstainVotes += votes;
        }
        
        totalVotesCast += votes;
        lastVoteTime[msg.sender] = block.timestamp;
        
        emit VoteCast(msg.sender, proposalId, support, votes);
    }
    
    function executeProposal(quantum_uint256 proposalId) quantum_safe {
        require(proposals[proposalId].id > 0, "Proposal does not exist");
        require(block.timestamp > proposals[proposalId].endTime, "Voting not ended");
        require(!proposals[proposalId].executed, "Proposal already executed");
        
        quantum_uint256 totalVotes = proposals[proposalId].forVotes + 
                                    proposals[proposalId].againstVotes + 
                                    proposals[proposalId].abstainVotes;
        
        require(totalVotes > 0, "No votes cast");
        require(proposals[proposalId].forVotes > proposals[proposalId].againstVotes, "Proposal rejected");
        
        proposals[proposalId].executed = quantum_true;
        
        // Execute proposal based on type
        if (keccak256(abi.encodePacked(proposals[proposalId].proposalType)) == keccak256("TREASURY_WITHDRAWAL")) {
            // Handle treasury withdrawal
        } else if (keccak256(abi.encodePacked(proposals[proposalId].proposalType)) == keccak256("VALIDATOR_ADD")) {
            // Handle validator addition
        } else if (keccak256(abi.encodePacked(proposals[proposalId].proposalType)) == keccak256("PARAMETER_CHANGE")) {
            // Handle parameter changes
        }
        
        emit ProposalExecuted(proposalId);
    }
    
    // üíé VALIDATOR FUNCTIONS
    function addValidator(quantum_address validator, quantum_uint256 stake) 
        quantum_safe 
        onlyOwner 
        validAddress(validator) {
        
        require(stake >= minValidatorStake, "Insufficient stake");
        require(!validators[validator], "Already a validator");
        
        validators[validator] = quantum_true;
        validatorStakes[validator] = stake;
        
        emit ValidatorAdded(validator, stake);
    }
    
    function removeValidator(quantum_address validator) 
        quantum_safe 
        onlyOwner 
        validAddress(validator) {
        
        require(validators[validator], "Not a validator");
        
        validators[validator] = quantum_false;
        validatorStakes[validator] = 0;
    }
    
    // üîÑ TREASURY FUNCTIONS
    function withdrawFromTreasury(quantum_address to, quantum_uint256 amount, quantum_string memory purpose) 
        quantum_safe 
        onlyTreasury 
        validAddress(to) {
        
        require(treasuryBalance >= amount, "Insufficient treasury balance");
        require(amount > 0, "Amount must be positive");
        
        treasuryBalance -= amount;
        treasuryWithdrawals[to] += amount;
        
        emit TreasuryWithdrawal(to, amount, purpose);
    }
    
    function allocateTreasury(quantum_string memory category, quantum_uint256 amount) 
        quantum_safe 
        onlyTreasury {
        
        require(treasuryBalance >= amount, "Insufficient treasury balance");
        
        treasuryAllocations[category] += amount;
        treasuryBalance -= amount;
    }
    
    // üõ°Ô∏è ANTI-FRAUD FUNCTIONS
    function blacklistAddress(quantum_address account, quantum_bool isBlacklisted) 
        quantum_safe 
        onlyOwner 
        validAddress(account) {
        
        blacklistedAddresses[account] = isBlacklisted;
        emit BlacklistUpdated(account, isBlacklisted);
    }
    
    function setDailyTransferLimit(quantum_address account, quantum_uint256 limit) 
        quantum_safe 
        onlyOwner 
        validAddress(account) {
        
        dailyTransferLimits[account] = limit;
    }
    
    // üìä ANALYTICS FUNCTIONS
    function getGovernanceStats() quantum_view returns (
        quantum_uint256 _totalSupply,
        quantum_uint256 _totalVotesCast,
        quantum_uint256 _proposalCount,
        quantum_uint256 _treasuryBalance
    ) {
        return (
            totalSupply,
            totalVotesCast,
            proposalCount,
            treasuryBalance
        );
    }
    
    function getUserGovernanceStats(quantum_address user) quantum_view returns (
        quantum_uint256 balance,
        quantum_uint256 votingPower,
        quantum_uint256 delegatedVotes,
        quantum_uint256 lastVote
    ) {
        return (
            balances[user],
            votingPower[user],
            delegatedVotes[user],
            lastVoteTime[user]
        );
    }
    
    function getProposalInfo(quantum_uint256 proposalId) quantum_view returns (
        quantum_string memory title,
        quantum_string memory description,
        quantum_uint256 startTime,
        quantum_uint256 endTime,
        quantum_uint256 forVotes,
        quantum_uint256 againstVotes,
        quantum_uint256 abstainVotes,
        quantum_bool executed
    ) {
        Proposal memory proposal = proposals[proposalId];
        return (
            proposal.title,
            proposal.description,
            proposal.startTime,
            proposal.endTime,
            proposal.forVotes,
            proposal.againstVotes,
            proposal.abstainVotes,
            proposal.executed
        );
    }
}
