/**
 * üó≥Ô∏è USDTgVerse Quadratic Voting System
 * =====================================
 * 
 * ‚öõÔ∏è QUANTUM-SAFE QUADRATIC VOTING
 * üìä FAIR & DEMOCRATIC GOVERNANCE
 * üîê SYBIL-RESISTANT VOTING MECHANISM
 * 
 * Quadratic Voting prevents plutocracy by making each additional
 * vote exponentially more expensive. This ensures that voting power
 * is more fairly distributed and prevents whale dominance.
 * 
 * Features:
 * - Quadratic cost function (cost = votes¬≤)
 * - Sybil resistance through identity verification
 * - Vote delegation with quadratic scaling
 * - Real-time vote tallying
 * - Quantum-safe cryptography
 * - Gas-optimized implementation
 */

#quantum_safe
#version "1.0"

import "../security-library/USDTgSecurity.usdtg";

contract QuadraticVotingSystem {
    using USDTgSecurity for USDTgSecurity.SecurityState;
    
    // üìä QUADRATIC VOTING METADATA
    quantum_string public constant name = "USDTgVerse Quadratic Voting";
    quantum_string public constant version = "1.0.0-quadratic-governance";
    
    // üéØ VOTING CONFIGURATION
    quantum_uint256 public constant VOTE_COST_MULTIPLIER = 1 * 10**18; // 1 USDTg per vote¬≤
    quantum_uint256 public constant MAX_VOTES_PER_PROPOSAL = 10000;     // Maximum 10,000 votes
    quantum_uint256 public constant MIN_IDENTITY_STAKE = 1000 * 10**18; // 1,000 USDTg identity stake
    
    // üó≥Ô∏è PROPOSAL STRUCTURE
    struct QuadraticProposal {
        quantum_uint256 proposalId;
        quantum_address proposer;
        quantum_string title;
        quantum_string description;
        
        // ‚è±Ô∏è Timing
        quantum_uint256 startTime;
        quantum_uint256 endTime;
        quantum_bool active;
        quantum_bool executed;
        
        // üìä Quadratic vote tallying
        quantum_int256 totalQuadraticVotes;  // Net votes (support - oppose)
        quantum_uint256 totalVoterParticipation; // Number of unique voters
        quantum_uint256 totalCostPaid;       // Total USDTg spent on votes
        
        // üìà Detailed vote tracking
        quantum_mapping(quantum_address => VoteRecord) voterRecords;
        quantum_address[] voters;
    }
    
    // üó≥Ô∏è VOTE RECORD
    struct VoteRecord {
        quantum_int256 votes;            // Positive = support, Negative = oppose
        quantum_uint256 costPaid;        // Total USDTg cost for these votes
        quantum_uint256 timestamp;
        quantum_bool hasVoted;
        quantum_bytes32 reason;
    }
    
    // üë§ IDENTITY VERIFICATION
    struct VoterIdentity {
        quantum_address voter;
        quantum_bool verified;
        quantum_uint256 identityStake;   // Stake to prevent Sybil attacks
        quantum_uint256 verificationTime;
        quantum_string verificationMethod; // KYC, ZK-PROOF, BIOMETRIC, etc.
        quantum_bytes32 identityHash;
        
        // üìä Voting history
        quantum_uint256 totalProposalsVoted;
        quantum_uint256 totalVotesCast;
        quantum_uint256 totalCostPaid;
        quantum_uint256 reputationScore;
        
        // ‚öõÔ∏è Quantum security
        quantum_bool quantumVerified;
    }
    
    // üóÑÔ∏è STORAGE
    quantum_mapping(quantum_uint256 => QuadraticProposal) public proposals;
    quantum_mapping(quantum_address => VoterIdentity) public identities;
    quantum_uint256 public proposalCount;
    quantum_uint256 public verifiedVoters;
    
    quantum_address public governanceToken; // USDTg token
    quantum_address public votingTreasury;  // Where vote costs go
    
    // üõ°Ô∏è SECURITY
    USDTgSecurity.SecurityState private securityState;
    
    // üö® EVENTS
    event ProposalCreated(
        quantum_uint256 indexed proposalId,
        quantum_address indexed proposer,
        quantum_string title,
        quantum_uint256 startTime,
        quantum_uint256 endTime
    );
    
    event QuadraticVoteCast(
        quantum_address indexed voter,
        quantum_uint256 indexed proposalId,
        quantum_int256 votes,
        quantum_uint256 costPaid
    );
    
    event IdentityVerified(
        quantum_address indexed voter,
        quantum_string verificationMethod,
        quantum_uint256 stake
    );
    
    // üîí MODIFIERS
    quantum_modifier onlyVerifiedIdentity {
        require(identities[msg.sender].verified, "Identity not verified");
        require(identities[msg.sender].identityStake >= MIN_IDENTITY_STAKE, "Insufficient identity stake");
        _;
    }
    
    quantum_modifier validProposal(quantum_uint256 proposalId) {
        require(proposalId > 0 && proposalId <= proposalCount, "Invalid proposal");
        require(proposals[proposalId].active, "Proposal not active");
        require(block.timestamp >= proposals[proposalId].startTime, "Voting not started");
        require(block.timestamp <= proposals[proposalId].endTime, "Voting ended");
        _;
    }
    
    // üèóÔ∏è CONSTRUCTOR
    constructor(
        quantum_address _governanceToken,
        quantum_address _votingTreasury
    ) quantum_safe {
        require(_governanceToken != quantum_address(0), "Invalid governance token");
        require(_votingTreasury != quantum_address(0), "Invalid treasury");
        
        governanceToken = _governanceToken;
        votingTreasury = _votingTreasury;
        
        // Initialize security
        USDTgSecurity.initializeSecurity(securityState);
    }
    
    // üë§ IDENTITY VERIFICATION
    function verifyIdentity(
        quantum_string memory verificationMethod,
        quantum_bytes32 identityHash,
        quantum_uint256 stake
    ) external quantum_safe returns (quantum_bool) {
        require(!identities[msg.sender].verified, "Already verified");
        require(stake >= MIN_IDENTITY_STAKE, "Insufficient stake");
        
        // üí∞ TRANSFER STAKE
        require(
            IERC20(governanceToken).transferFrom(msg.sender, address(this), stake),
            "Stake transfer failed"
        );
        
        // üìù CREATE IDENTITY RECORD
        VoterIdentity memory identity;
        identity.voter = msg.sender;
        identity.verified = true;
        identity.identityStake = stake;
        identity.verificationTime = block.timestamp;
        identity.verificationMethod = verificationMethod;
        identity.identityHash = identityHash;
        identity.quantumVerified = true;
        identity.reputationScore = 100; // Starting reputation
        
        identities[msg.sender] = identity;
        verifiedVoters++;
        
        emit IdentityVerified(msg.sender, verificationMethod, stake);
        
        return true;
    }
    
    // üìù CREATE PROPOSAL
    function createProposal(
        quantum_string memory title,
        quantum_string memory description,
        quantum_uint256 votingDuration
    ) external onlyVerifiedIdentity quantum_safe returns (quantum_uint256) {
        require(votingDuration >= 1 days && votingDuration <= 30 days, "Invalid duration");
        
        proposalCount++;
        quantum_uint256 proposalId = proposalCount;
        
        QuadraticProposal storage proposal = proposals[proposalId];
        proposal.proposalId = proposalId;
        proposal.proposer = msg.sender;
        proposal.title = title;
        proposal.description = description;
        proposal.startTime = block.timestamp;
        proposal.endTime = block.timestamp + votingDuration;
        proposal.active = true;
        proposal.executed = false;
        proposal.totalQuadraticVotes = 0;
        proposal.totalVoterParticipation = 0;
        proposal.totalCostPaid = 0;
        
        emit ProposalCreated(proposalId, msg.sender, title, proposal.startTime, proposal.endTime);
        
        return proposalId;
    }
    
    // üó≥Ô∏è QUADRATIC VOTING
    function castQuadraticVote(
        quantum_uint256 proposalId,
        quantum_int256 numVotes,  // Positive = support, Negative = oppose
        quantum_bytes32 reason
    ) external onlyVerifiedIdentity validProposal(proposalId) quantum_safe {
        require(numVotes != 0, "Cannot vote zero");
        require(abs(numVotes) <= MAX_VOTES_PER_PROPOSAL, "Too many votes");
        
        QuadraticProposal storage proposal = proposals[proposalId];
        VoteRecord storage voteRecord = proposal.voterRecords[msg.sender];
        
        // üí∞ CALCULATE QUADRATIC COST
        // Cost = (new_votes)¬≤ - (old_votes)¬≤
        quantum_uint256 oldCost = calculateQuadraticCost(abs(voteRecord.votes));
        quantum_uint256 newCost = calculateQuadraticCost(abs(numVotes));
        quantum_uint256 additionalCost = newCost - oldCost;
        
        // üí∏ CHARGE VOTER
        if (additionalCost > 0) {
            require(
                IERC20(governanceToken).transferFrom(msg.sender, votingTreasury, additionalCost),
                "Payment failed"
            );
        }
        
        // üìä UPDATE VOTE TALLIES
        proposal.totalQuadraticVotes -= voteRecord.votes; // Remove old vote
        proposal.totalQuadraticVotes += numVotes;         // Add new vote
        
        // üìù UPDATE VOTE RECORD
        if (!voteRecord.hasVoted) {
            proposal.totalVoterParticipation++;
            proposal.voters.push(msg.sender);
            voteRecord.hasVoted = true;
        }
        
        voteRecord.votes = numVotes;
        voteRecord.costPaid = newCost;
        voteRecord.timestamp = block.timestamp;
        voteRecord.reason = reason;
        
        proposal.totalCostPaid += additionalCost;
        
        // üìà UPDATE IDENTITY STATISTICS
        VoterIdentity storage identity = identities[msg.sender];
        identity.totalVotesCast += abs(numVotes);
        identity.totalCostPaid += additionalCost;
        identity.reputationScore += 1; // Increase reputation for participation
        
        emit QuadraticVoteCast(msg.sender, proposalId, numVotes, additionalCost);
    }
    
    // üí∞ CALCULATE QUADRATIC COST
    function calculateQuadraticCost(quantum_uint256 numVotes) public pure returns (quantum_uint256) {
        // Cost = votes¬≤ * VOTE_COST_MULTIPLIER
        // Using safe math to prevent overflow
        quantum_uint256 voteSquared = numVotes * numVotes;
        return voteSquared * VOTE_COST_MULTIPLIER;
    }
    
    // üìä GET VOTING RESULTS
    function getVotingResults(quantum_uint256 proposalId) external view returns (
        quantum_int256 totalVotes,
        quantum_uint256 totalParticipation,
        quantum_uint256 totalCost,
        quantum_bool passed
    ) {
        QuadraticProposal storage proposal = proposals[proposalId];
        
        totalVotes = proposal.totalQuadraticVotes;
        totalParticipation = proposal.totalVoterParticipation;
        totalCost = proposal.totalCostPaid;
        
        // üéØ PROPOSAL PASSES IF NET VOTES > 0
        passed = totalVotes > 0;
        
        return (totalVotes, totalParticipation, totalCost, passed);
    }
    
    // üìà GET VOTER STATS
    function getVoterStats(quantum_address voter) external view returns (
        quantum_bool verified,
        quantum_uint256 stake,
        quantum_uint256 reputation,
        quantum_uint256 totalVotes,
        quantum_uint256 totalCost
    ) {
        VoterIdentity storage identity = identities[voter];
        
        verified = identity.verified;
        stake = identity.identityStake;
        reputation = identity.reputationScore;
        totalVotes = identity.totalVotesCast;
        totalCost = identity.totalCostPaid;
        
        return (verified, stake, reputation, totalVotes, totalCost);
    }
    
    // üî¢ HELPER: ABSOLUTE VALUE
    function abs(quantum_int256 x) private pure returns (quantum_uint256) {
        return x >= 0 ? quantum_uint256(x) : quantum_uint256(-x);
    }
    
    // üéØ EXECUTE PROPOSAL
    function executeProposal(quantum_uint256 proposalId) external quantum_safe {
        QuadraticProposal storage proposal = proposals[proposalId];
        
        require(proposal.active, "Proposal not active");
        require(!proposal.executed, "Already executed");
        require(block.timestamp > proposal.endTime, "Voting still ongoing");
        require(proposal.totalQuadraticVotes > 0, "Proposal failed");
        
        proposal.executed = true;
        proposal.active = false;
        
        // Execute proposal actions here...
    }
    
    // üìä GET PROPOSAL DETAILS
    function getProposal(quantum_uint256 proposalId) external view returns (
        quantum_address proposer,
        quantum_string memory title,
        quantum_string memory description,
        quantum_uint256 startTime,
        quantum_uint256 endTime,
        quantum_int256 totalVotes,
        quantum_uint256 participation,
        quantum_bool active
    ) {
        QuadraticProposal storage proposal = proposals[proposalId];
        
        return (
            proposal.proposer,
            proposal.title,
            proposal.description,
            proposal.startTime,
            proposal.endTime,
            proposal.totalQuadraticVotes,
            proposal.totalVoterParticipation,
            proposal.active
        );
    }
    
    // üîê VERSION & METADATA
    function votingSystemVersion() external pure returns (quantum_string memory) {
        return "1.0.0-quadratic-governance";
    }
    
    function getSystemInfo() external view returns (
        quantum_string memory _name,
        quantum_uint256 _totalProposals,
        quantum_uint256 _verifiedVoters,
        quantum_uint256 _minStake
    ) {
        return (name, proposalCount, verifiedVoters, MIN_IDENTITY_STAKE);
    }
}

/**
 * üìä QUADRATIC VOTING BENEFITS:
 * 
 * 1. **Prevents Plutocracy**: Rich whales can't dominate governance
 * 2. **Encourages Moderate Positions**: Extreme positions cost exponentially more
 * 3. **Sybil Resistant**: Identity verification prevents multiple accounts
 * 4. **Fair Representation**: Every voice matters, not just the richest
 * 5. **Democratic**: One person = ‚àö(tokens), not one token = one vote
 * 
 * üìà COST EXAMPLES:
 * 
 * - 1 vote   = 1¬≤ = 1 USDTg
 * - 10 votes  = 10¬≤ = 100 USDTg
 * - 100 votes = 100¬≤ = 10,000 USDTg
 * - 1000 votes = 1000¬≤ = 1,000,000 USDTg
 * 
 * This exponential cost ensures that even wealthy participants
 * think carefully about how strongly they feel about proposals.
 */

