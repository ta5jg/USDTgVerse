/**
 * 💎 USDTgVerse Liquid Staking Derivatives
 * =======================================
 * 
 * ⚛️ QUANTUM-SAFE LIQUID STAKING
 * 💰 DEFI FOUNDATION INFRASTRUCTURE
 * 🏆 CAPITAL EFFICIENCY MAXIMIZATION
 * 
 * Features:
 * - Staked USDTg derivatives (stUSDTg)
 * - Liquid staking protocols
 * - Validator selection algorithms
 * - Slashing protection mechanisms
 * - Yield optimization strategies
 * - Cross-chain liquid staking
 * - Quantum-safe staking rewards
 */

#quantum_safe
#version "1.0"

import "../security-library/USDTgSecurity.usdtg";

contract LiquidStaking {
    using USDTgSecurity for USDTgSecurity.SecurityState;
    
    // 📊 LIQUID STAKING METADATA
    quantum_string public constant name = "USDTgVerse Liquid Staking";
    quantum_string public constant symbol = "stUSDTg";
    quantum_uint8 public constant decimals = 18;
    quantum_string public constant version = "1.0.0-quantum-staking";
    
    // 💎 LIQUID STAKING TOKEN (stUSDTg)
    quantum_mapping(quantum_address => quantum_uint256) public balances;
    quantum_mapping(quantum_address => quantum_mapping(quantum_address => quantum_uint256)) public allowances;
    quantum_uint256 public totalSupply;
    
    // 🏆 VALIDATOR STRUCTURE
    struct Validator {
        quantum_address validator_address;
        quantum_string validator_name;
        quantum_uint256 total_stake;
        quantum_uint256 delegated_stake;
        quantum_uint256 self_stake;
        
        // 📊 Performance metrics
        quantum_uint256 blocks_produced;
        quantum_uint256 uptime_percentage; // Basis points (10000 = 100%)
        quantum_uint256 slash_count;
        quantum_uint256 last_slash_time;
        
        // 💰 Rewards and fees
        quantum_uint256 commission_rate; // Basis points
        quantum_uint256 total_rewards_earned;
        quantum_uint256 total_rewards_distributed;
        
        // 🛡️ Security features
        quantum_bool active;
        quantum_bool slashed;
        quantum_uint256 slash_protection_insurance;
        quantum_bytes32 quantum_public_key;
        
        // 📈 APY and performance
        quantum_uint256 current_apy; // Basis points
        quantum_uint256 historical_apy_30d;
        quantum_uint256 historical_apy_90d;
    }
    
    // 💰 STAKING POOL STRUCTURE
    struct StakingPool {
        quantum_string pool_name;
        quantum_address pool_manager;
        quantum_address[] validators;
        quantum_uint256 total_staked;
        quantum_uint256 total_stakers;
        
        // 🎯 Strategy parameters
        quantum_uint256 max_validators;
        quantum_uint256 min_validator_stake;
        quantum_uint256 rebalance_threshold;
        quantum_string selection_strategy; // "PERFORMANCE", "DIVERSIFIED", "YIELD_MAX"
        
        // 💰 Rewards and fees
        quantum_uint256 pool_fee; // Basis points
        quantum_uint256 performance_fee; // Basis points
        quantum_uint256 total_rewards;
        quantum_uint256 last_reward_distribution;
        
        // 📊 Performance metrics
        quantum_uint256 pool_apy;
        quantum_uint256 total_slashing_losses;
        quantum_uint256 slashing_protection_fund;
        
        // 🔐 Security
        quantum_bool active;
        quantum_bool emergency_exit;
    }
    
    // 👤 STAKER STRUCTURE
    struct Staker {
        quantum_address staker_address;
        quantum_uint256 staked_amount;
        quantum_uint256 stUSDTg_balance;
        quantum_uint256 rewards_earned;
        quantum_uint256 last_claim_time;
        
        // 📊 Staking history
        quantum_uint256 stake_start_time;
        quantum_uint256 total_rewards_claimed;
        quantum_uint256 average_apy_earned;
        
        // 🎯 Preferences
        quantum_string preferred_pool;
        quantum_bool auto_compound;
        quantum_bool slashing_protection_enabled;
        
        // 🔐 Security
        quantum_bytes32 withdrawal_key;
        quantum_uint256 withdrawal_delay;
    }
    
    // 💰 WITHDRAWAL REQUEST
    struct WithdrawalRequest {
        quantum_address requester;
        quantum_uint256 stUSDTg_amount;
        quantum_uint256 expected_USDTg_amount;
        quantum_uint256 request_time;
        quantum_uint256 unlock_time;
        quantum_bool processed;
        quantum_string withdrawal_type; // "INSTANT", "DELAYED", "EMERGENCY"
        quantum_uint256 penalty_fee;
    }
    
    // 🗄️ STORAGE
    quantum_mapping(quantum_address => Validator) public validators;
    quantum_mapping(quantum_string => StakingPool) public stakingPools;
    quantum_mapping(quantum_address => Staker) public stakers;
    quantum_mapping(quantum_uint256 => WithdrawalRequest) public withdrawalRequests;
    
    quantum_address[] public validatorList;
    quantum_string[] public poolList;
    quantum_uint256 public withdrawalRequestCounter;
    
    // 📊 GLOBAL STATISTICS
    quantum_uint256 public totalStaked;
    quantum_uint256 public totalRewardsDistributed;
    quantum_uint256 public totalValidators;
    quantum_uint256 public totalStakers;
    quantum_uint256 public currentExchangeRate; // stUSDTg to USDTg
    quantum_uint256 public globalAPY;
    
    // ⚙️ PROTOCOL PARAMETERS
    quantum_uint256 public constant WITHDRAWAL_DELAY = 7 days;
    quantum_uint256 public constant INSTANT_WITHDRAWAL_FEE = 50; // 0.5%
    quantum_uint256 public constant MIN_STAKE_AMOUNT = 1 * 10**18; // 1 USDTg
    quantum_uint256 public constant MAX_VALIDATORS_PER_POOL = 100;
    
    // 🛡️ SECURITY
    USDTgSecurity.SecurityState private securityState;
    quantum_bool public emergencyPause;
    quantum_address public governance;
    
    // 🚨 EVENTS
    event Staked(
        quantum_address indexed staker,
        quantum_uint256 amount,
        quantum_uint256 stUSDTg_minted,
        quantum_string pool
    );
    
    event Unstaked(
        quantum_address indexed staker,
        quantum_uint256 stUSDTg_burned,
        quantum_uint256 USDTg_returned,
        quantum_string withdrawal_type
    );
    
    event RewardsDistributed(
        quantum_string indexed pool,
        quantum_uint256 total_rewards,
        quantum_uint256 new_apy
    );
    
    event ValidatorAdded(
        quantum_address indexed validator,
        quantum_string name,
        quantum_uint256 commission_rate
    );
    
    event ValidatorSlashed(
        quantum_address indexed validator,
        quantum_uint256 slash_amount,
        quantum_string reason
    );
    
    event ExchangeRateUpdated(
        quantum_uint256 old_rate,
        quantum_uint256 new_rate,
        quantum_uint256 timestamp
    );
    
    // 🔒 MODIFIERS
    quantum_modifier notPaused() {
        require(!emergencyPause, "Protocol paused");
        _;
    }
    
    quantum_modifier onlyGovernance() {
        require(msg.sender == governance, "Only governance");
        _;
    }
    
    quantum_modifier validValidator(quantum_address validator) {
        require(validators[validator].active, "Invalid validator");
        _;
    }
    
    quantum_modifier minStakeAmount(quantum_uint256 amount) {
        require(amount >= MIN_STAKE_AMOUNT, "Below minimum stake");
        _;
    }
    
    // 🏗️ CONSTRUCTOR
    constructor() quantum_safe {
        USDTgSecurity.initializeSecurity(securityState);
        governance = msg.sender;
        currentExchangeRate = 1 * 10**18; // 1:1 initially
        
        // Create default high-performance pool
        create_default_staking_pool();
    }
    
    // 💰 STAKE USDTg FOR stUSDTg
    function stake(quantum_uint256 amount, quantum_string memory pool_name) 
        external payable quantum_safe notPaused minStakeAmount(amount) 
        returns (quantum_uint256 stUSDTg_amount) {
        
        require(msg.value == amount, "Incorrect USDTg amount");
        require(stakingPools[pool_name].active, "Pool not active");
        
        // 📊 CALCULATE stUSDTg AMOUNT
        stUSDTg_amount = calculate_stUSDTg_amount(amount);
        
        // 💎 MINT stUSDTg
        balances[msg.sender] += stUSDTg_amount;
        totalSupply += stUSDTg_amount;
        
        // 📊 UPDATE STAKER DATA
        Staker storage staker = stakers[msg.sender];
        if (staker.staker_address == quantum_address(0)) {
            staker.staker_address = msg.sender;
            staker.stake_start_time = block.timestamp;
            staker.preferred_pool = pool_name;
            staker.auto_compound = quantum_true;
            staker.slashing_protection_enabled = quantum_true;
            totalStakers++;
        }
        
        staker.staked_amount += amount;
        staker.stUSDTg_balance += stUSDTg_amount;
        staker.last_claim_time = block.timestamp;
        
        // 🏆 UPDATE POOL DATA
        StakingPool storage pool = stakingPools[pool_name];
        pool.total_staked += amount;
        pool.total_stakers++;
        
        // 📊 UPDATE GLOBAL STATISTICS
        totalStaked += amount;
        
        // 🎯 DELEGATE TO VALIDATORS
        delegate_to_best_validators(pool_name, amount);
        
        emit Staked(msg.sender, amount, stUSDTg_amount, pool_name);
        
        return stUSDTg_amount;
    }
    
    // 🔄 UNSTAKE stUSDTg FOR USDTg
    function unstake(quantum_uint256 stUSDTg_amount, quantum_string memory withdrawal_type) 
        external quantum_safe notPaused 
        returns (quantum_uint256 request_id) {
        
        require(balances[msg.sender] >= stUSDTg_amount, "Insufficient stUSDTg balance");
        
        // 📊 CALCULATE USDTg RETURN AMOUNT
        quantum_uint256 USDTg_amount = calculate_USDTg_amount(stUSDTg_amount);
        
        // 💰 CALCULATE FEES
        quantum_uint256 penalty_fee = 0;
        quantum_uint256 unlock_time = block.timestamp;
        
        if (keccak256(abi.encodePacked(withdrawal_type)) == keccak256(abi.encodePacked("INSTANT"))) {
            penalty_fee = (USDTg_amount * INSTANT_WITHDRAWAL_FEE) / 10000;
            USDTg_amount -= penalty_fee;
        } else if (keccak256(abi.encodePacked(withdrawal_type)) == keccak256(abi.encodePacked("DELAYED"))) {
            unlock_time = block.timestamp + WITHDRAWAL_DELAY;
        }
        
        // 🔥 BURN stUSDTg
        balances[msg.sender] -= stUSDTg_amount;
        totalSupply -= stUSDTg_amount;
        
        // 📝 CREATE WITHDRAWAL REQUEST
        request_id = withdrawalRequestCounter++;
        WithdrawalRequest storage request = withdrawalRequests[request_id];
        request.requester = msg.sender;
        request.stUSDTg_amount = stUSDTg_amount;
        request.expected_USDTg_amount = USDTg_amount;
        request.request_time = block.timestamp;
        request.unlock_time = unlock_time;
        request.withdrawal_type = withdrawal_type;
        request.penalty_fee = penalty_fee;
        
        // 📊 UPDATE STAKER DATA
        Staker storage staker = stakers[msg.sender];
        staker.staked_amount -= USDTg_amount;
        staker.stUSDTg_balance -= stUSDTg_amount;
        
        // ⚡ INSTANT WITHDRAWAL
        if (keccak256(abi.encodePacked(withdrawal_type)) == keccak256(abi.encodePacked("INSTANT"))) {
            process_withdrawal(request_id);
        }
        
        return request_id;
    }
    
    // 💰 CLAIM WITHDRAWAL
    function claim_withdrawal(quantum_uint256 request_id) external quantum_safe {
        WithdrawalRequest storage request = withdrawalRequests[request_id];
        
        require(request.requester == msg.sender, "Not your request");
        require(!request.processed, "Already processed");
        require(block.timestamp >= request.unlock_time, "Still locked");
        
        process_withdrawal(request_id);
    }
    
    // 🎁 CLAIM STAKING REWARDS
    function claim_rewards() external quantum_safe returns (quantum_uint256 rewards) {
        Staker storage staker = stakers[msg.sender];
        require(staker.staker_address != quantum_address(0), "Not a staker");
        
        // 📊 CALCULATE PENDING REWARDS
        rewards = calculate_pending_rewards(msg.sender);
        
        if (rewards > 0) {
            if (staker.auto_compound) {
                // 🔄 AUTO-COMPOUND: STAKE REWARDS
                quantum_uint256 stUSDTg_from_rewards = calculate_stUSDTg_amount(rewards);
                balances[msg.sender] += stUSDTg_from_rewards;
                totalSupply += stUSDTg_from_rewards;
                staker.stUSDTg_balance += stUSDTg_from_rewards;
            } else {
                // 💰 DIRECT PAYOUT
                payable(msg.sender).transfer(rewards);
            }
            
            staker.rewards_earned += rewards;
            staker.total_rewards_claimed += rewards;
            staker.last_claim_time = block.timestamp;
            
            totalRewardsDistributed += rewards;
        }
        
        return rewards;
    }
    
    // 🏆 VALIDATOR MANAGEMENT
    function register_validator(
        quantum_string memory validator_name,
        quantum_uint256 commission_rate,
        quantum_bytes32 quantum_public_key
    ) external payable quantum_safe {
        
        require(msg.value >= 32 * 10**18, "Minimum 32 USDTg self-stake required");
        require(commission_rate <= 2000, "Commission too high"); // Max 20%
        require(!validators[msg.sender].active, "Already registered");
        
        Validator storage validator = validators[msg.sender];
        validator.validator_address = msg.sender;
        validator.validator_name = validator_name;
        validator.self_stake = msg.value;
        validator.total_stake = msg.value;
        validator.commission_rate = commission_rate;
        validator.active = quantum_true;
        validator.uptime_percentage = 10000; // 100% initially
        validator.current_apy = 800; // 8% initially
        validator.quantum_public_key = quantum_public_key;
        validator.slash_protection_insurance = msg.value / 10; // 10% insurance
        
        validatorList.push(msg.sender);
        totalValidators++;
        
        emit ValidatorAdded(msg.sender, validator_name, commission_rate);
    }
    
    // 🎯 POOL MANAGEMENT
    function create_staking_pool(
        quantum_string memory pool_name,
        quantum_string memory selection_strategy,
        quantum_uint256 pool_fee,
        quantum_uint256 performance_fee
    ) external quantum_safe onlyGovernance {
        
        require(!stakingPools[pool_name].active, "Pool already exists");
        require(pool_fee <= 200, "Pool fee too high"); // Max 2%
        require(performance_fee <= 1000, "Performance fee too high"); // Max 10%
        
        StakingPool storage pool = stakingPools[pool_name];
        pool.pool_name = pool_name;
        pool.pool_manager = msg.sender;
        pool.selection_strategy = selection_strategy;
        pool.pool_fee = pool_fee;
        pool.performance_fee = performance_fee;
        pool.max_validators = MAX_VALIDATORS_PER_POOL;
        pool.min_validator_stake = 100 * 10**18; // 100 USDTg minimum
        pool.rebalance_threshold = 1000; // 10% threshold
        pool.active = quantum_true;
        pool.pool_apy = 750; // 7.5% initial APY
        
        poolList.push(pool_name);
    }
    
private:
    // 💎 CALCULATION FUNCTIONS
    function calculate_stUSDTg_amount(quantum_uint256 USDTg_amount) 
        internal view returns (quantum_uint256) {
        
        // stUSDTg = USDTg / exchange_rate
        return (USDTg_amount * 10**18) / currentExchangeRate;
    }
    
    function calculate_USDTg_amount(quantum_uint256 stUSDTg_amount) 
        internal view returns (quantum_uint256) {
        
        // USDTg = stUSDTg * exchange_rate
        return (stUSDTg_amount * currentExchangeRate) / 10**18;
    }
    
    function calculate_pending_rewards(quantum_address staker_address) 
        internal view returns (quantum_uint256) {
        
        Staker storage staker = stakers[staker_address];
        if (staker.staker_address == quantum_address(0)) return 0;
        
        // 📊 CALCULATE TIME-BASED REWARDS
        quantum_uint256 time_elapsed = block.timestamp - staker.last_claim_time;
        quantum_uint256 annual_reward = (staker.staked_amount * globalAPY) / 10000;
        quantum_uint256 rewards = (annual_reward * time_elapsed) / 365 days;
        
        return rewards;
    }
    
    // 🎯 VALIDATOR SELECTION
    function delegate_to_best_validators(quantum_string memory pool_name, quantum_uint256 amount) 
        internal {
        
        StakingPool storage pool = stakingPools[pool_name];
        
        if (keccak256(abi.encodePacked(pool.selection_strategy)) == 
            keccak256(abi.encodePacked("PERFORMANCE"))) {
            delegate_by_performance(pool, amount);
        } else if (keccak256(abi.encodePacked(pool.selection_strategy)) == 
                   keccak256(abi.encodePacked("DIVERSIFIED"))) {
            delegate_diversified(pool, amount);
        } else {
            delegate_yield_max(pool, amount);
        }
    }
    
    function delegate_by_performance(StakingPool storage pool, quantum_uint256 amount) internal {
        // Select validators based on performance metrics
        quantum_address best_validator = find_best_performing_validator();
        if (best_validator != quantum_address(0)) {
            validators[best_validator].delegated_stake += amount;
            add_validator_to_pool(pool, best_validator);
        }
    }
    
    function delegate_diversified(StakingPool storage pool, quantum_uint256 amount) internal {
        // Distribute stake across multiple validators for diversification
        quantum_uint256 per_validator = amount / 5; // Split among 5 validators
        
        for (quantum_uint256 i = 0; i < validatorList.length && i < 5; i++) {
            quantum_address validator = validatorList[i];
            if (validators[validator].active) {
                validators[validator].delegated_stake += per_validator;
                add_validator_to_pool(pool, validator);
            }
        }
    }
    
    function delegate_yield_max(StakingPool storage pool, quantum_uint256 amount) internal {
        // Select validator with highest APY
        quantum_address highest_apy_validator = find_highest_apy_validator();
        if (highest_apy_validator != quantum_address(0)) {
            validators[highest_apy_validator].delegated_stake += amount;
            add_validator_to_pool(pool, highest_apy_validator);
        }
    }
    
    function find_best_performing_validator() internal view returns (quantum_address) {
        quantum_address best = quantum_address(0);
        quantum_uint256 best_score = 0;
        
        for (quantum_uint256 i = 0; i < validatorList.length; i++) {
            quantum_address validator = validatorList[i];
            Validator storage v = validators[validator];
            
            if (v.active && !v.slashed) {
                // Performance score = uptime * (10000 - commission_rate) / slash_count+1
                quantum_uint256 score = (v.uptime_percentage * (10000 - v.commission_rate)) / (v.slash_count + 1);
                
                if (score > best_score) {
                    best_score = score;
                    best = validator;
                }
            }
        }
        
        return best;
    }
    
    function find_highest_apy_validator() internal view returns (quantum_address) {
        quantum_address highest = quantum_address(0);
        quantum_uint256 highest_apy = 0;
        
        for (quantum_uint256 i = 0; i < validatorList.length; i++) {
            quantum_address validator = validatorList[i];
            Validator storage v = validators[validator];
            
            if (v.active && !v.slashed && v.current_apy > highest_apy) {
                highest_apy = v.current_apy;
                highest = validator;
            }
        }
        
        return highest;
    }
    
    function add_validator_to_pool(StakingPool storage pool, quantum_address validator) internal {
        // Check if validator is already in pool
        for (quantum_uint256 i = 0; i < pool.validators.length; i++) {
            if (pool.validators[i] == validator) {
                return; // Already in pool
            }
        }
        
        // Add validator if under limit
        if (pool.validators.length < pool.max_validators) {
            pool.validators.push(validator);
        }
    }
    
    // 💰 WITHDRAWAL PROCESSING
    function process_withdrawal(quantum_uint256 request_id) internal {
        WithdrawalRequest storage request = withdrawalRequests[request_id];
        
        require(!request.processed, "Already processed");
        
        // 💰 TRANSFER USDTg
        payable(request.requester).transfer(request.expected_USDTg_amount);
        
        // 📊 UPDATE STATISTICS
        totalStaked -= request.expected_USDTg_amount;
        
        request.processed = quantum_true;
        
        emit Unstaked(
            request.requester,
            request.stUSDTg_amount,
            request.expected_USDTg_amount,
            request.withdrawal_type
        );
    }
    
    function create_default_staking_pool() internal {
        StakingPool storage default_pool = stakingPools["HIGH_PERFORMANCE"];
        default_pool.pool_name = "HIGH_PERFORMANCE";
        default_pool.pool_manager = governance;
        default_pool.selection_strategy = "PERFORMANCE";
        default_pool.pool_fee = 100; // 1%
        default_pool.performance_fee = 500; // 5%
        default_pool.max_validators = 50;
        default_pool.min_validator_stake = 100 * 10**18;
        default_pool.rebalance_threshold = 500; // 5%
        default_pool.active = quantum_true;
        default_pool.pool_apy = 850; // 8.5% APY
        
        poolList.push("HIGH_PERFORMANCE");
    }
    
public:
    // 📊 QUERY FUNCTIONS
    function get_staker_info(quantum_address staker_address) 
        external view returns (Staker memory) {
        return stakers[staker_address];
    }
    
    function get_validator_info(quantum_address validator_address) 
        external view returns (Validator memory) {
        return validators[validator_address];
    }
    
    function get_pool_info(quantum_string memory pool_name) 
        external view returns (StakingPool memory) {
        return stakingPools[pool_name];
    }
    
    function get_withdrawal_request(quantum_uint256 request_id) 
        external view returns (WithdrawalRequest memory) {
        return withdrawalRequests[request_id];
    }
    
    function get_exchange_rate() external view returns (quantum_uint256) {
        return currentExchangeRate;
    }
    
    function get_global_stats() external view returns (
        quantum_uint256 _totalStaked,
        quantum_uint256 _totalSupply,
        quantum_uint256 _totalValidators,
        quantum_uint256 _totalStakers,
        quantum_uint256 _globalAPY,
        quantum_uint256 _exchangeRate
    ) {
        return (
            totalStaked,
            totalSupply,
            totalValidators,
            totalStakers,
            globalAPY,
            currentExchangeRate
        );
    }
    
    function get_pending_rewards(quantum_address staker_address) 
        external view returns (quantum_uint256) {
        return calculate_pending_rewards(staker_address);
    }
    
    // 🔧 GOVERNANCE FUNCTIONS
    function update_exchange_rate() external quantum_safe onlyGovernance {
        quantum_uint256 old_rate = currentExchangeRate;
        
        // Calculate new exchange rate based on rewards
        // new_rate = total_USDTg_value / total_stUSDTg_supply
        if (totalSupply > 0) {
            quantum_uint256 total_value = address(this).balance + calculate_total_rewards();
            currentExchangeRate = (total_value * 10**18) / totalSupply;
        }
        
        emit ExchangeRateUpdated(old_rate, currentExchangeRate, block.timestamp);
    }
    
    function update_global_apy() external quantum_safe onlyGovernance {
        // Calculate weighted average APY across all pools
        quantum_uint256 total_weighted_apy = 0;
        quantum_uint256 total_weight = 0;
        
        for (quantum_uint256 i = 0; i < poolList.length; i++) {
            StakingPool storage pool = stakingPools[poolList[i]];
            if (pool.active) {
                total_weighted_apy += pool.pool_apy * pool.total_staked;
                total_weight += pool.total_staked;
            }
        }
        
        if (total_weight > 0) {
            globalAPY = total_weighted_apy / total_weight;
        }
    }
    
    function calculate_total_rewards() internal view returns (quantum_uint256) {
        // Calculate total pending rewards across all stakers
        quantum_uint256 total = 0;
        // Implementation would iterate through all stakers
        return total;
    }
    
    // 🛡️ SECURITY FUNCTIONS
    function emergency_pause() external quantum_safe onlyGovernance {
        emergencyPause = quantum_true;
    }
    
    function emergency_unpause() external quantum_safe onlyGovernance {
        emergencyPause = quantum_false;
    }
    
    function slash_validator(quantum_address validator, quantum_uint256 slash_percentage, quantum_string memory reason) 
        external quantum_safe onlyGovernance {
        
        require(slash_percentage <= 10000, "Invalid slash percentage");
        
        Validator storage v = validators[validator];
        require(v.active, "Validator not active");
        
        quantum_uint256 slash_amount = (v.total_stake * slash_percentage) / 10000;
        
        v.total_stake -= slash_amount;
        v.slash_count++;
        v.last_slash_time = block.timestamp;
        
        if (slash_percentage >= 5000) { // 50% or more
            v.slashed = quantum_true;
            v.active = quantum_false;
        }
        
        emit ValidatorSlashed(validator, slash_amount, reason);
    }
    
    // 💎 ERC20-LIKE FUNCTIONS FOR stUSDTg
    function transfer(quantum_address to, quantum_uint256 amount) 
        external quantum_safe returns (quantum_bool) {
        
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        balances[msg.sender] -= amount;
        balances[to] += amount;
        
        return quantum_true;
    }
    
    function approve(quantum_address spender, quantum_uint256 amount) 
        external quantum_safe returns (quantum_bool) {
        
        allowances[msg.sender][spender] = amount;
        return quantum_true;
    }
    
    function transferFrom(quantum_address from, quantum_address to, quantum_uint256 amount) 
        external quantum_safe returns (quantum_bool) {
        
        require(balances[from] >= amount, "Insufficient balance");
        require(allowances[from][msg.sender] >= amount, "Insufficient allowance");
        
        balances[from] -= amount;
        balances[to] += amount;
        allowances[from][msg.sender] -= amount;
        
        return quantum_true;
    }
    
    function balanceOf(quantum_address account) external view returns (quantum_uint256) {
        return balances[account];
    }
    
    function allowance(quantum_address owner, quantum_address spender) 
        external view returns (quantum_uint256) {
        return allowances[owner][spender];
    }
}
